# HG changeset patch
# Parent 6dfd6edc540a74730c21f8e43df04d16ad70702b

diff --git a/src/main/java/org/yaml/snakeyaml/introspector/PropertyUtils.java b/src/main/java/org/yaml/snakeyaml/introspector/PropertyUtils.java
--- a/src/main/java/org/yaml/snakeyaml/introspector/PropertyUtils.java
+++ b/src/main/java/org/yaml/snakeyaml/introspector/PropertyUtils.java
@@ -15,11 +15,7 @@
  */
 package org.yaml.snakeyaml.introspector;
 
-import java.beans.IntrospectionException;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
 import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.Collection;
 import java.util.HashMap;
@@ -43,50 +39,14 @@
         }
 
         Map<String, Property> properties = new LinkedHashMap<String, Property>();
-        boolean inaccessableFieldsExist = false;
-        switch (bAccess) {
-        case FIELD:
-            for (Class<?> c = type; c != null; c = c.getSuperclass()) {
-                for (Field field : c.getDeclaredFields()) {
-                    int modifiers = field.getModifiers();
-                    if (!Modifier.isStatic(modifiers) && !Modifier.isTransient(modifiers)
-                            && !properties.containsKey(field.getName())) {
-                        properties.put(field.getName(), new FieldProperty(field));
-                    }
+        for (Class<?> c = type; c != null; c = c.getSuperclass()) {
+            for (Field field : c.getDeclaredFields()) {
+                int modifiers = field.getModifiers();
+                if (!Modifier.isStatic(modifiers) && !Modifier.isTransient(modifiers)
+                        && !properties.containsKey(field.getName())) {
+                    properties.put(field.getName(), new FieldProperty(field));
                 }
             }
-            break;
-        default:
-            // add JavaBean properties
-            try {
-                for (PropertyDescriptor property : Introspector.getBeanInfo(type)
-                        .getPropertyDescriptors()) {
-                    Method readMethod = property.getReadMethod();
-                    if (readMethod == null || !readMethod.getName().equals("getClass")) {
-                        properties.put(property.getName(), new MethodProperty(property));
-                    }
-                }
-            } catch (IntrospectionException e) {
-                throw new YAMLException(e);
-            }
-
-            // add public fields
-            for (Class<?> c = type; c != null; c = c.getSuperclass()) {
-                for (Field field : c.getDeclaredFields()) {
-                    int modifiers = field.getModifiers();
-                    if (!Modifier.isStatic(modifiers) && !Modifier.isTransient(modifiers)) {
-                        if (Modifier.isPublic(modifiers)) {
-                            properties.put(field.getName(), new FieldProperty(field));
-                        } else {
-                            inaccessableFieldsExist = true;
-                        }
-                    }
-                }
-            }
-            break;
-        }
-        if (properties.isEmpty() && inaccessableFieldsExist) {
-            throw new YAMLException("No JavaBean properties found in " + type.getName());
         }
         propertiesCache.put(type, properties);
         return properties;
